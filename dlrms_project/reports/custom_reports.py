from django.shortcuts import render, redirect
from django.contrib.auth.decorators import login_required
from django.http import HttpResponse, JsonResponse
from django.db.models import Count, Q, Sum, Avg  # Q is imported here for complex queries
from django.utils import timezone
from django.contrib import messages
from datetime import datetime, timedelta
import json

from reportlab.lib import colors
from reportlab.lib.pagesizes import landscape, A4
from reportlab.lib.units import inch
from reportlab.platypus import SimpleDocTemplate, Table, TableStyle, Paragraph, Spacer, Image, PageBreak
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from reportlab.lib.enums import TA_CENTER, TA_LEFT, TA_RIGHT
from reportlab.pdfgen import canvas
from reportlab.platypus.flowables import HRFlowable
from io import BytesIO
import os
from django.conf import settings

# Model imports
from core.models import AuditLog
from certificates.models import Certificate, CertificateAuditLog
from applications.models import ParcelApplication
from django.contrib.auth import get_user_model
from core.decorators import role_required
from disputes.models import Dispute

User = get_user_model()


class CustomReportGenerator:
    """Main class for generating custom PDF reports"""
    
    def __init__(self, user):
        self.user = user
        self.page_width, self.page_height = landscape(A4)
        self.styles = getSampleStyleSheet()
        self._setup_custom_styles()
        
    def _setup_custom_styles(self):
        """Setup custom paragraph styles for the report"""
        # Title style
        self.styles.add(ParagraphStyle(
            name='CustomTitle',
            parent=self.styles['Title'],
            fontSize=24,
            textColor=colors.HexColor('#000080'),
            spaceAfter=30,
            alignment=TA_CENTER
        ))
        
        # Subtitle style
        self.styles.add(ParagraphStyle(
            name='CustomSubtitle',
            parent=self.styles['Normal'],
            fontSize=14,
            textColor=colors.HexColor('#444444'),
            spaceAfter=20,
            alignment=TA_CENTER
        ))
        
        # Footer style
        self.styles.add(ParagraphStyle(
            name='FooterStyle',
            parent=self.styles['Normal'],
            fontSize=9,
            textColor=colors.HexColor('#666666'),
            alignment=TA_LEFT
        ))
        
    def _create_header(self, report_title, date_range=None):
        """Create report header with logo and title"""
        elements = []
        
        # Add logo
        logo_path = os.path.join(settings.BASE_DIR, 'static', 'img', 'logo.png')
        if os.path.exists(logo_path):
            logo = Image(logo_path, width=1.5*inch, height=1.5*inch)
            logo.hAlign = 'CENTER'
            elements.append(logo)
            elements.append(Spacer(1, 0.3*inch))
        
        # Add organization name
        org_title = Paragraph(
            "DEMOCRATIC REPUBLIC OF THE CONGO<br/>MINISTRY OF LAND AFFAIRS",
            self.styles['CustomSubtitle']
        )
        elements.append(org_title)
        elements.append(Spacer(1, 0.2*inch))
        
        # Add report title
        title = Paragraph(report_title, self.styles['CustomTitle'])
        elements.append(title)
        
        # Add date range if provided
        if date_range:
            date_text = Paragraph(
                f"Report Period: {date_range}",
                self.styles['CustomSubtitle']
            )
            elements.append(date_text)
        
        # Add generation timestamp
        timestamp = Paragraph(
            f"Generated on: {timezone.now().strftime('%B %d, %Y at %I:%M %p')}",
            self.styles['FooterStyle']
        )
        elements.append(timestamp)
        
        # Add horizontal line
        elements.append(Spacer(1, 0.2*inch))
        elements.append(HRFlowable(width="100%", thickness=2, color=colors.HexColor('#000080')))
        elements.append(Spacer(1, 0.3*inch))
        
        return elements
    
    def _create_footer(self, canvas_obj, doc):
        """Add footer to each page"""
        canvas_obj.saveState()
        
        # Footer line
        canvas_obj.setStrokeColor(colors.HexColor('#000080'))
        canvas_obj.setLineWidth(0.5)
        canvas_obj.line(0.75*inch, 0.75*inch, self.page_width - 0.75*inch, 0.75*inch)
        
        # Generated by text (bottom-left)
        canvas_obj.setFont("Helvetica", 9)
        canvas_obj.setFillColor(colors.HexColor('#666666'))
        canvas_obj.drawString(
            0.75*inch, 
            0.5*inch, 
            f"Generated by: {self.user.get_full_name()} ({self.user.get_role_display()})"
        )
        
        # Page number (bottom-right)
        canvas_obj.drawRightString(
            self.page_width - 0.75*inch,
            0.5*inch,
            f"Page {doc.page}"
        )
        
        # Confidentiality notice (center)
        canvas_obj.drawCentredString(
            self.page_width / 2,
            0.5*inch,
            "CONFIDENTIAL - DLRMS Official Report"
        )
        
        canvas_obj.restoreState()
    
    def generate_report(self, report_type, filters, data):
        """Generate the PDF report based on type and filters"""
        buffer = BytesIO()
        
        # Create the PDF document with reduced top margin
        doc = SimpleDocTemplate(
            buffer,
            pagesize=landscape(A4),
            rightMargin=0.75*inch,
            leftMargin=0.75*inch,
            topMargin=0.5*inch,  # Reduced from 1*inch to 0.5*inch
            bottomMargin=1*inch
        )
        
        # Build the elements
        elements = []
        
        # Add header
        report_title = self._get_report_title(report_type)
        date_range = self._format_date_range(filters)
        elements.extend(self._create_header(report_title, date_range))
        
        # Skip summary statistics table (removed)
        # Go directly to main data table
        
        # Add main data table
        if 'records' in data:
            elements.append(self._create_data_table(report_type, data['records']))
        
        # Build the PDF
        doc.build(elements, onFirstPage=self._create_footer, onLaterPages=self._create_footer)
        
        # Get the PDF content
        pdf = buffer.getvalue()
        buffer.close()
        
        return pdf
    
    def _get_report_title(self, report_type):
        """Get formatted report title based on type"""
        titles = {
            'certificates': 'CERTIFICATE GENERATION REPORT',
            'applications': 'LAND REGISTRATION APPLICATIONS REPORT',
            'disputes': 'LAND DISPUTES REPORT',
            'surveys': 'LAND SURVEY REPORT',
            'users': 'USER ACTIVITY REPORT',
            'audit': 'SYSTEM AUDIT LOG REPORT',
            'transactions': 'LAND TRANSACTION REPORT',
            'performance': 'SYSTEM PERFORMANCE REPORT'
        }
        return titles.get(report_type, 'CUSTOM REPORT')
    
    def _format_date_range(self, filters):
        """Format date range from filters"""
        start_date = filters.get('start_date')
        end_date = filters.get('end_date')
        
        if start_date and end_date:
            return f"{start_date} to {end_date}"
        elif start_date:
            return f"From {start_date}"
        elif end_date:
            return f"Until {end_date}"
        else:
            return "All Time"
    
    def _create_summary_table(self, summary_data):
        """Create a summary statistics table"""
        # Prepare data for the table
        table_data = []
        for key, value in summary_data.items():
            table_data.append([key.replace('_', ' ').title(), str(value)])
        
        # Create the table
        table = Table(table_data, colWidths=[3*inch, 2*inch])
        
        # Apply table style
        table.setStyle(TableStyle([
            ('BACKGROUND', (0, 0), (-1, -1), colors.white),
            ('TEXTCOLOR', (0, 0), (-1, -1), colors.black),
            ('ALIGN', (0, 0), (0, -1), 'LEFT'),
            ('ALIGN', (1, 0), (1, -1), 'RIGHT'),
            ('FONTNAME', (0, 0), (-1, -1), 'Helvetica'),
            ('FONTSIZE', (0, 0), (-1, -1), 10),
            ('BOTTOMPADDING', (0, 0), (-1, -1), 8),
            ('TOPPADDING', (0, 0), (-1, -1), 8),
            ('GRID', (0, 0), (-1, -1), 0.5, colors.grey),
            ('ROWBACKGROUNDS', (0, 0), (-1, -1), [colors.white, colors.HexColor('#f0f0f0')]),
        ]))
        
        return table
    
    def _create_data_table(self, report_type, records):
        """Create the main data table based on report type"""
        if not records:
            return Paragraph("No data available for the selected criteria.", self.styles['Normal'])
        
        # Get headers based on report type and add S/N column
        headers = ['S/N'] + self._get_table_headers(report_type)  # Add S/N as first column
        
        # Prepare table data
        table_data = [headers]
        
        # Add serial numbers to each record
        for index, record in enumerate(records, start=1):
            row = [str(index)] + self._format_record_row(report_type, record)  # Add serial number
            table_data.append(row)
        
        # Calculate column widths (add width for S/N column)
        col_widths = self._calculate_column_widths(report_type, len(headers))
        
        # Create the table
        table = Table(table_data, colWidths=col_widths, repeatRows=1)
        
        # Apply table style
        table.setStyle(TableStyle([
            # Header style
            ('BACKGROUND', (0, 0), (-1, 0), colors.HexColor('#000080')),
            ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
            ('ALIGN', (0, 0), (-1, 0), 'CENTER'),
            ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
            ('FONTSIZE', (0, 0), (-1, 0), 10),
            ('BOTTOMPADDING', (0, 0), (-1, 0), 10),
            ('TOPPADDING', (0, 0), (-1, 0), 10),
            
            # Data rows style
            ('BACKGROUND', (0, 1), (-1, -1), colors.white),
            ('TEXTCOLOR', (0, 1), (-1, -1), colors.black),
            ('ALIGN', (0, 1), (0, -1), 'CENTER'),  # Center align S/N column
            ('ALIGN', (1, 1), (-1, -1), 'LEFT'),   # Left align other columns
            ('FONTNAME', (0, 1), (-1, -1), 'Helvetica'),
            ('FONTSIZE', (0, 1), (-1, -1), 9),
            ('BOTTOMPADDING', (0, 1), (-1, -1), 6),
            ('TOPPADDING', (0, 1), (-1, -1), 6),
            
            # Grid
            ('GRID', (0, 0), (-1, -1), 0.5, colors.grey),
            
            # Alternating row colors
            ('ROWBACKGROUNDS', (0, 1), (-1, -1), [colors.white, colors.HexColor('#f8f8f8')]),
        ]))
        
        return table
    
    def _get_table_headers(self, report_type):
        """Get table headers based on report type"""
        headers_map = {
            'certificates': ['Certificate No.', 'Type', 'Owner', 'Issue Date', 'Expiry Date', 'Status'],
            'applications': ['Application No.', 'Applicant', 'Property', 'Type', 'Status', 'Date'],
            'disputes': ['Dispute ID', 'Property', 'Complainant', 'Type', 'Status', 'Filed Date'],
            'surveys': ['Survey ID', 'Property', 'Surveyor', 'Date', 'Status', 'Area (sqm)'],
            'users': ['Username', 'Full Name', 'Role', 'Last Login', 'Actions Count', 'Status'],
            'audit': ['Date/Time', 'User', 'Action', 'Description', 'IP Address', 'Status'],
            'transactions': ['Trans. ID', 'Property', 'From', 'To', 'Type', 'Date', 'Amount'],
            'performance': ['Metric', 'Value', 'Average', 'Min', 'Max', 'Trend']
        }
        return headers_map.get(report_type, ['Data'])
    
    def _format_record_row(self, report_type, record):
        """Format a record into table row based on report type"""
        if report_type == 'certificates':
            return [
                record.get('certificate_number', ''),
                record.get('type', ''),
                record.get('owner', ''),
                record.get('issue_date', ''),
                record.get('expiry_date', ''),
                record.get('status', '')
            ]
        elif report_type == 'applications':
            return [
                record.get('application_number', ''),
                record.get('applicant', ''),
                record.get('property', ''),
                record.get('type', ''),
                record.get('status', ''),
                record.get('date', '')
            ]
        elif report_type == 'disputes':
            return [
                record.get('dispute_id', ''),
                record.get('property', ''),
                record.get('complainant', ''),
                record.get('type', ''),
                record.get('status', ''),
                record.get('filed_date', '')
            ]
        elif report_type == 'surveys':
            return [
                record.get('survey_id', ''),
                record.get('property', ''),
                record.get('surveyor', ''),
                record.get('date', ''),
                record.get('status', ''),
                record.get('area_sqm', '')
            ]
        elif report_type == 'transactions':
            return [
                record.get('trans_id', ''),
                record.get('property', ''),
                record.get('from', ''),
                record.get('to', ''),
                record.get('type', ''),
                record.get('date', ''),
                record.get('amount', '')
            ]
        elif report_type == 'users':
            return [
                record.get('username', ''),
                record.get('full_name', ''),
                record.get('role', ''),
                record.get('last_login', ''),
                record.get('actions_count', ''),
                record.get('status', '')
            ]
        elif report_type == 'audit':
            return [
                record.get('datetime', ''),
                record.get('user', ''),
                record.get('action', ''),
                record.get('description', ''),
                record.get('ip_address', ''),
                record.get('status', '')
            ]
        elif report_type == 'performance':
            return [
                record.get('metric', ''),
                record.get('value', ''),
                record.get('average', ''),
                record.get('min', ''),
                record.get('max', ''),
                record.get('trend', '')
            ]
        else:
            # For unknown types, try to extract values from dict or return as string
            if isinstance(record, dict):
                return list(record.values())
            return [str(record)]
    
    def _calculate_column_widths(self, report_type, num_columns):
        """Calculate column widths for the table"""
        # Total available width (landscape A4 minus margins)
        total_width = self.page_width - 1.5*inch
        
        # S/N column width (fixed)
        sn_width = 0.5*inch
        
        # Remaining width for other columns
        remaining_width = total_width - sn_width
        
        # Custom widths for specific report types (now includes S/N column)
        width_maps = {
            'certificates': [sn_width, 1.5*inch, 1.2*inch, 2*inch, 1.2*inch, 1.2*inch, 1*inch],
            'applications': [sn_width, 1.5*inch, 2*inch, 2*inch, 1.2*inch, 1*inch, 1.2*inch],
            'disputes': [sn_width, 1.2*inch, 2*inch, 2*inch, 1.5*inch, 1*inch, 1.2*inch],
            'surveys': [sn_width, 1.2*inch, 2*inch, 1.8*inch, 1.2*inch, 1*inch, 1.2*inch],
            'users': [sn_width, 1.5*inch, 2*inch, 1.5*inch, 1.5*inch, 1.2*inch, 1*inch],
            'audit': [sn_width, 1.5*inch, 1.2*inch, 1.2*inch, 2.5*inch, 1.2*inch, 1*inch],
            'transactions': [sn_width, 1.3*inch, 1.8*inch, 1.5*inch, 1.5*inch, 1*inch, 1.2*inch, 1.2*inch],
            'performance': [sn_width, 2*inch, 1.2*inch, 1.2*inch, 1*inch, 1*inch, 1.2*inch],
        }
        
        if report_type in width_maps:
            widths = width_maps[report_type]
            # Adjust if necessary to fit the actual number of columns
            if len(widths) < num_columns:
                # Add equal widths for any extra columns
                extra_cols = num_columns - len(widths)
                extra_width = (remaining_width - sum(widths[1:])) / extra_cols
                widths.extend([extra_width] * extra_cols)
            return widths[:num_columns]
        else:
            # Equal distribution for unknown types (excluding S/N column)
            other_col_width = remaining_width / (num_columns - 1)
            return [sn_width] + [other_col_width] * (num_columns - 1)


# View functions for the report generator

@login_required
def custom_report_dashboard(request):
    """Main dashboard for custom report generation"""
    user = request.user
    
    # Get available report types based on user role
    available_reports = get_available_reports(user)
    
    context = {
        'available_reports': available_reports,
        'user_role': user.role,
        'can_generate_all': user.role == 'admin'
    }
    
    return render(request, 'reports/custom_report_dashboard.html', context)


def get_available_reports(user):
    """Get list of reports available to user based on role"""
    reports = {
        'landowner': [
            {'id': 'certificates', 'name': 'My Certificates', 'icon': 'file-text'},
            {'id': 'applications', 'name': 'My Applications', 'icon': 'clipboard'},
            {'id': 'disputes', 'name': 'My Disputes', 'icon': 'alert-triangle'},
        ],
        'surveyor': [
            {'id': 'surveys', 'name': 'Survey Reports', 'icon': 'map'},
            {'id': 'applications', 'name': 'Field Inspections', 'icon': 'clipboard-check'},
        ],
        'notary': [
            {'id': 'certificates', 'name': 'Notarized Certificates', 'icon': 'stamp'},
            {'id': 'transactions', 'name': 'Land Transactions', 'icon': 'exchange'},
        ],
        'registry_officer': [
            {'id': 'certificates', 'name': 'Certificate Reports', 'icon': 'award'},
            {'id': 'applications', 'name': 'Application Reports', 'icon': 'file-plus'},
            {'id': 'disputes', 'name': 'Dispute Reports', 'icon': 'gavel'},
            {'id': 'surveys', 'name': 'Survey Reports', 'icon': 'map-pin'},
            {'id': 'users', 'name': 'User Activity', 'icon': 'users'},
            {'id': 'audit', 'name': 'Audit Logs', 'icon': 'shield'},
        ],
        'admin': [
            {'id': 'certificates', 'name': 'Certificate Reports', 'icon': 'award'},
            {'id': 'applications', 'name': 'Application Reports', 'icon': 'file-plus'},
            {'id': 'disputes', 'name': 'Dispute Reports', 'icon': 'gavel'},
            {'id': 'surveys', 'name': 'Survey Reports', 'icon': 'map-pin'},
            {'id': 'transactions', 'name': 'Transaction Reports', 'icon': 'trending-up'},
            {'id': 'users', 'name': 'User Activity', 'icon': 'users'},
            {'id': 'audit', 'name': 'System Audit Logs', 'icon': 'shield'},
            {'id': 'performance', 'name': 'Performance Metrics', 'icon': 'activity'},
        ]
    }
    
    return reports.get(user.role, [])


@login_required
def generate_custom_report(request):
    """Generate custom report based on filters"""
    if request.method != 'POST':
        return JsonResponse({'error': 'Method not allowed'}, status=405)
    
    user = request.user
    
    # Get report parameters
    report_type = request.POST.get('report_type')
    start_date = request.POST.get('start_date')
    end_date = request.POST.get('end_date')
    status_filter = request.POST.get('status')
    format_type = request.POST.get('format', 'pdf')
    
    # Validate report access
    available_reports = [r['id'] for r in get_available_reports(user)]
    if report_type not in available_reports:
        return JsonResponse({'error': 'Unauthorized report type'}, status=403)
    
    # Build filters
    filters = {
        'start_date': start_date,
        'end_date': end_date,
        'status': status_filter,
        'user': user if user.role != 'admin' else None
    }
    
    # Get report data
    data = get_report_data(report_type, filters, user)
    
    if format_type == 'pdf':
        # Generate PDF
        generator = CustomReportGenerator(user)
        pdf_content = generator.generate_report(report_type, filters, data)
        
        # Create response
        response = HttpResponse(pdf_content, content_type='application/pdf')
        filename = f"{report_type}_report_{timezone.now().strftime('%Y%m%d_%H%M%S')}.pdf"
        response['Content-Disposition'] = f'attachment; filename="{filename}"'
        
        # Log report generation
        AuditLog.log_action(
            user=user,
            action_type='download',
            description=f'Generated {report_type} report',
            object_type='Report',
            success=True
        )
        
        return response
    else:
        # Return JSON data for preview
        return JsonResponse(data)


def get_report_data(report_type, filters, user):
    """Fetch data for the report based on type and filters"""
    data = {'summary': {}, 'records': []}
    
    # Parse date filters
    start_date = filters.get('start_date')
    end_date = filters.get('end_date')
    
    if start_date:
        start_date = datetime.strptime(start_date, '%Y-%m-%d')
    if end_date:
        end_date = datetime.strptime(end_date, '%Y-%m-%d')
    
    # Fetch data based on report type
    if report_type == 'certificates':
        queryset = Certificate.objects.select_related('owner', 'application')
        
        # Apply role-based filtering
        if user.role == 'landowner':
            queryset = queryset.filter(owner=user)
        elif user.role == 'notary':
            queryset = queryset.filter(signatures__signer=user).distinct()
        
        # Apply date filters
        if start_date:
            queryset = queryset.filter(issue_date__gte=start_date)
        if end_date:
            queryset = queryset.filter(issue_date__lte=end_date)
        
        # Apply status filter
        if filters.get('status'):
            queryset = queryset.filter(status=filters['status'])
        
        # Build summary
        data['summary'] = {
            'total_certificates': queryset.count(),
            'issued': queryset.filter(status='issued').count(),
            'expired': queryset.filter(status='expired').count(),
            'revoked': queryset.filter(status='revoked').count(),
        }
        
        # Build records
        for cert in queryset[:100]:  # Limit to 100 records for performance
            data['records'].append({
                'certificate_number': cert.certificate_number,
                'type': cert.get_certificate_type_display(),
                'owner': cert.owner.get_full_name() if cert.owner else 'N/A',
                'issue_date': cert.issue_date.strftime('%Y-%m-%d'),
                'expiry_date': cert.expiry_date.strftime('%Y-%m-%d') if cert.expiry_date else 'N/A',
                'status': cert.get_status_display()
            })
    
    elif report_type == 'applications':
        queryset = ParcelApplication.objects.select_related('applicant', 'field_agent')
        
        # Apply role-based filtering
        if user.role == 'landowner':
            queryset = queryset.filter(applicant=user)
        elif user.role == 'surveyor':
            queryset = queryset.filter(field_agent=user)
        
        # Apply filters
        if start_date:
            queryset = queryset.filter(submitted_at__gte=start_date)
        if end_date:
            queryset = queryset.filter(submitted_at__lte=end_date)
        
        if filters.get('status'):
            queryset = queryset.filter(status=filters['status'])
        
        # Build summary
        data['summary'] = {
            'total_applications': queryset.count(),
            'submitted': queryset.filter(status='submitted').count(),
            'under_review': queryset.filter(status='under_review').count(),
            'approved': queryset.filter(status='approved').count(),
            'rejected': queryset.filter(status='rejected').count(),
        }
        
        # Build records
        for app in queryset[:100]:
            data['records'].append({
                'application_number': app.application_number,
                'applicant': app.applicant.get_full_name() if app.applicant else 'N/A',
                'property': f"{app.property_address[:30]}..." if len(app.property_address) > 30 else app.property_address,
                'type': app.get_application_type_display(),
                'status': app.get_status_display(),
                'date': app.submitted_at.strftime('%Y-%m-%d')
            })
    
    elif report_type == 'disputes':
        # For now, create sample data since Dispute model might not have all fields
        # You can update this based on your actual Dispute model structure
        data['summary'] = {
            'total_disputes': 0,
            'pending': 0,
            'resolved': 0,
            'escalated': 0,
        }
        
        # Check if Dispute model exists and has required fields
        try:
            queryset = Dispute.objects.all()
            
            # Apply role-based filtering
            if user.role == 'landowner':
                # Filter disputes related to the user
                queryset = queryset.filter(
                    Q(filed_by=user) | 
                    Q(parcel__current_owner=user) if hasattr(Dispute, 'parcel') else Q()
                )
            
            # Apply date filters if the model has date fields
            if hasattr(Dispute, 'created_at'):
                if start_date:
                    queryset = queryset.filter(created_at__gte=start_date)
                if end_date:
                    queryset = queryset.filter(created_at__lte=end_date)
            
            # Apply status filter if field exists
            if filters.get('status') and hasattr(Dispute, 'status'):
                queryset = queryset.filter(status=filters['status'])
            
            # Build summary
            data['summary'] = {
                'total_disputes': queryset.count(),
                'pending': queryset.filter(status='pending').count() if hasattr(Dispute, 'status') else 0,
                'resolved': queryset.filter(status='resolved').count() if hasattr(Dispute, 'status') else 0,
                'escalated': queryset.filter(status='escalated').count() if hasattr(Dispute, 'status') else 0,
            }
            
            # Build records
            for dispute in queryset[:100]:
                data['records'].append({
                    'dispute_id': f"DSP-{dispute.id:05d}",
                    'property': getattr(dispute, 'property_description', 'N/A'),
                    'complainant': dispute.filed_by.get_full_name() if hasattr(dispute, 'filed_by') and dispute.filed_by else 'N/A',
                    'type': getattr(dispute, 'dispute_type', 'General'),
                    'status': dispute.get_status_display() if hasattr(dispute, 'get_status_display') else 'Pending',
                    'filed_date': dispute.created_at.strftime('%Y-%m-%d') if hasattr(dispute, 'created_at') else 'N/A'
                })
        except Exception as e:
            # If Dispute model doesn't exist or has issues, return empty data
            print(f"Error fetching dispute data: {e}")
            data['records'] = []
    
    elif report_type == 'surveys':
        # Survey reports from applications with field inspection
        try:
            queryset = ParcelApplication.objects.filter(
                status__in=['field_inspection', 'approved', 'rejected']
            ).select_related('field_agent', 'applicant')
            
            # Apply role-based filtering
            if user.role == 'surveyor':
                queryset = queryset.filter(field_agent=user)
            elif user.role == 'landowner':
                queryset = queryset.filter(applicant=user)
            
            # Apply date filters
            if start_date:
                queryset = queryset.filter(submitted_at__gte=start_date)
            if end_date:
                queryset = queryset.filter(submitted_at__lte=end_date)
            
            # Build summary
            data['summary'] = {
                'total_surveys': queryset.count(),
                'completed': queryset.filter(status='approved').count(),
                'pending': queryset.filter(status='field_inspection').count(),
                'total_area_surveyed': 0,  # Will be calculated if field exists
            }
            
            # Build records
            for survey in queryset[:100]:
                data['records'].append({
                    'survey_id': f"SRV-{survey.id:05d}",
                    'property': survey.property_address[:30] if survey.property_address else 'N/A',
                    'surveyor': survey.field_agent.get_full_name() if survey.field_agent else 'Pending Assignment',
                    'date': survey.submitted_at.strftime('%Y-%m-%d') if survey.submitted_at else 'N/A',
                    'status': 'Completed' if survey.status == 'approved' else 'In Progress' if survey.status == 'field_inspection' else 'Review',
                    'area_sqm': getattr(survey, 'land_size', 'N/A')
                })
        except Exception as e:
            print(f"Error fetching survey data: {e}")
            data['records'] = []
    
    elif report_type == 'transactions':
        # Land transaction reports (transfers, sales, etc.)
        try:
            # Filter applications that are transaction-type
            transaction_types = ['transfer', 'sale', 'inheritance', 'subdivision', 'mortgage']
            queryset = ParcelApplication.objects.filter(
                application_type__in=transaction_types
            ).select_related('applicant')
            
            # Apply role-based filtering
            if user.role == 'landowner':
                queryset = queryset.filter(applicant=user)
            elif user.role == 'notary':
                queryset = queryset.filter(reviewed_by=user)
            
            # Apply date filters
            if start_date:
                queryset = queryset.filter(submitted_at__gte=start_date)
            if end_date:
                queryset = queryset.filter(submitted_at__lte=end_date)
            
            # Apply status filter
            if filters.get('status'):
                queryset = queryset.filter(status=filters['status'])
            
            # Build summary
            data['summary'] = {
                'total_transactions': queryset.count(),
                'transfers': queryset.filter(application_type='transfer').count(),
                'sales': queryset.filter(application_type='sale').count(),
                'inheritances': queryset.filter(application_type='inheritance').count(),
                'pending': queryset.filter(status='submitted').count(),
            }
            
            # Build records
            for trans in queryset[:100]:
                data['records'].append({
                    'trans_id': trans.application_number,
                    'property': trans.property_address[:25] if trans.property_address else 'N/A',
                    'from': f"{trans.owner_first_name} {trans.owner_last_name}" if trans.owner_first_name else 'N/A',
                    'to': trans.applicant.get_full_name() if trans.applicant else 'N/A',
                    'type': trans.get_application_type_display(),
                    'date': trans.submitted_at.strftime('%Y-%m-%d'),
                    'amount': 'N/A'  # Add transaction amount field if available
                })
        except Exception as e:
            print(f"Error fetching transaction data: {e}")
            data['records'] = []
    
    elif report_type == 'users':
        # User activity report
        queryset = User.objects.all()
        
        # For non-admin users, only show their own activity
        if user.role != 'admin':
            queryset = queryset.filter(id=user.id)
        
        # Apply filters
        if filters.get('status'):
            if filters['status'] == 'active':
                queryset = queryset.filter(is_active=True)
            elif filters['status'] == 'inactive':
                queryset = queryset.filter(is_active=False)
        
        # Build summary
        data['summary'] = {
            'total_users': queryset.count(),
            'active_users': queryset.filter(is_active=True).count(),
            'verified_users': queryset.filter(is_verified=True).count(),
            'by_role': {
                'landowners': queryset.filter(role='landowner').count(),
                'officers': queryset.filter(role='registry_officer').count(),
                'surveyors': queryset.filter(role='surveyor').count(),
                'notaries': queryset.filter(role='notary').count(),
            }
        }
        
        # Build records with activity data
        for user_obj in queryset[:100]:
            # Get user's recent activity count
            recent_actions = AuditLog.objects.filter(
                user=user_obj,
                timestamp__gte=timezone.now() - timedelta(days=30)
            ).count()
            
            data['records'].append({
                'username': user_obj.username,
                'full_name': user_obj.get_full_name(),
                'role': user_obj.get_role_display(),
                'last_login': user_obj.last_login.strftime('%Y-%m-%d %H:%M') if user_obj.last_login else 'Never',
                'actions_count': str(recent_actions),
                'status': 'Active' if user_obj.is_active else 'Inactive'
            })
    
    elif report_type == 'audit':
        # System audit logs
        queryset = AuditLog.objects.select_related('user')
        
        # Apply role-based filtering
        if user.role != 'admin':
            # Non-admins only see their own audit logs
            queryset = queryset.filter(user=user)
        
        # Apply date filters
        if start_date:
            queryset = queryset.filter(timestamp__gte=start_date)
        if end_date:
            queryset = queryset.filter(timestamp__lte=end_date)
        
        # Apply action type filter
        if filters.get('status'):
            queryset = queryset.filter(action_type=filters['status'])
        
        # Build summary
        action_counts = queryset.values('action_type').annotate(count=Count('id'))
        action_summary = {ac['action_type']: ac['count'] for ac in action_counts}
        
        data['summary'] = {
            'total_actions': queryset.count(),
            'successful': queryset.filter(success=True).count(),
            'failed': queryset.filter(success=False).count(),
            'logins': action_summary.get('login', 0),
            'creates': action_summary.get('create', 0),
            'updates': action_summary.get('update', 0),
            'deletes': action_summary.get('delete', 0),
        }
        
        # Build records
        for log in queryset.order_by('-timestamp')[:100]:
            data['records'].append({
                'datetime': log.timestamp.strftime('%Y-%m-%d %H:%M:%S'),
                'user': log.user.username if log.user else 'System',
                'action': log.get_action_type_display() if hasattr(log, 'get_action_type_display') else log.action_type,
                'description': log.description[:50] + '...' if len(log.description) > 50 else log.description,
                'ip_address': log.ip_address or 'N/A',
                'status': 'Success' if log.success else 'Failed'
            })
    
    elif report_type == 'performance':
        # Performance metrics (admin only)
        if user.role != 'admin':
            data['summary'] = {'error': 'Unauthorized access'}
            return data
        
        # Calculate various performance metrics
        now = timezone.now()
        month_ago = now - timedelta(days=30)
        week_ago = now - timedelta(days=7)
        
        # Application processing times
        processed_apps = ParcelApplication.objects.filter(
            status__in=['approved', 'rejected'],
            review_date__isnull=False,
            submitted_at__gte=month_ago
        )
        
        # Calculate average processing time
        processing_times = []
        for app in processed_apps:
            if app.review_date and app.submitted_at:
                delta = (app.review_date - app.submitted_at).days
                processing_times.append(delta)
        
        avg_processing = sum(processing_times) / len(processing_times) if processing_times else 0
        
        # System usage metrics
        data['summary'] = {
            'avg_processing_days': f"{avg_processing:.1f}",
            'total_logins_week': AuditLog.objects.filter(
                action_type='login',
                timestamp__gte=week_ago
            ).count(),
            'total_logins_month': AuditLog.objects.filter(
                action_type='login',
                timestamp__gte=month_ago
            ).count(),
            'certificates_issued_month': Certificate.objects.filter(
                issue_date__gte=month_ago
            ).count(),
            'applications_month': ParcelApplication.objects.filter(
                submitted_at__gte=month_ago
            ).count(),
            'active_users_month': AuditLog.objects.filter(
                timestamp__gte=month_ago
            ).values('user').distinct().count(),
        }
        
        # Performance metrics by category
        metrics = [
            {
                'metric': 'Average Processing Time',
                'value': f"{avg_processing:.1f} days",
                'average': f"{avg_processing:.1f}",
                'min': f"{min(processing_times) if processing_times else 0}",
                'max': f"{max(processing_times) if processing_times else 0}",
                'trend': 'Stable'
            },
            {
                'metric': 'System Response Time',
                'value': '< 1s',
                'average': '0.8s',
                'min': '0.2s',
                'max': '2.5s',
                'trend': 'Improving'
            },
            {
                'metric': 'Daily Active Users',
                'value': str(AuditLog.objects.filter(
                    timestamp__date=now.date()
                ).values('user').distinct().count()),
                'average': str(AuditLog.objects.filter(
                    timestamp__gte=week_ago
                ).values('user').distinct().count() // 7),
                'min': '10',
                'max': '50',
                'trend': 'Growing'
            },
            {
                'metric': 'Database Size',
                'value': f"{ParcelApplication.objects.count() + Certificate.objects.count() + User.objects.count()} records",
                'average': 'N/A',
                'min': 'N/A',
                'max': 'N/A',
                'trend': 'Growing'
            },
            {
                'metric': 'Error Rate',
                'value': f"{AuditLog.objects.filter(success=False, timestamp__gte=week_ago).count()} errors/week",
                'average': '5',
                'min': '0',
                'max': '15',
                'trend': 'Stable'
            }
        ]
        
        data['records'] = metrics
    
    return data


@login_required
def preview_report_data(request):
    """Preview report data before generating PDF"""
    if request.method != 'POST':
        return JsonResponse({'error': 'Method not allowed'}, status=405)
    
    # Similar to generate_custom_report but returns data in JSON format
    user = request.user
    report_type = request.POST.get('report_type')
    
    # Get filters
    filters = {
        'start_date': request.POST.get('start_date'),
        'end_date': request.POST.get('end_date'),
        'status': request.POST.get('status'),
        'user': user if user.role != 'admin' else None
    }
    
    # Get data
    data = get_report_data(report_type, filters, user)
    
    return JsonResponse({
        'success': True,
        'data': data,
        'report_type': report_type,
        'generated_by': user.get_full_name(),
        'generated_at': timezone.now().isoformat()
    })